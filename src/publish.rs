//! Publish a skillpack to a registry by opening a PR via `gh`.

use std::path::Path;
use std::process::Command;

use crate::error::Error;
use crate::index::EXTRA_DIRS;
use crate::pack::{self, PackResult};

/// Result of publishing a skillpack.
#[derive(Debug)]
pub struct PublishResult {
    pub pack: PackResult,
    pub pr_url: String,
}

/// Pack the skill and open a PR against the registry repo.
///
/// `repo` is in `owner/repo` format (e.g. "joshrotenberg/skillet-registry").
/// `registry_path` overrides the destination path in the registry. If `None`,
/// the default `owner/name/` layout is used.
/// If `dry_run` is true, stops after packing and prints what would happen.
pub fn publish(
    dir: &Path,
    repo: &str,
    registry_path: Option<&str>,
    dry_run: bool,
) -> crate::error::Result<PublishResult> {
    let pack_result = pack::pack(dir)?;

    let owner = &pack_result.validation.owner;
    let name = &pack_result.validation.name;
    let version = &pack_result.validation.version;

    let dest_rel = registry_path
        .map(|s| s.to_string())
        .unwrap_or_else(|| format!("{owner}/{name}"));

    if dry_run {
        println!("\nDry run: would publish {owner}/{name} v{version} to {repo}");
        println!("  - Fork {repo} (or use existing fork)");
        println!("  - Create branch: publish/{owner}/{name}/{version}");
        println!("  - Copy skillpack into {dest_rel}/");
        println!("  - Open PR against {repo}");
        return Ok(PublishResult {
            pack: pack_result,
            pr_url: "(dry run)".to_string(),
        });
    }

    // Check that gh is available
    check_gh_cli()?;

    // Fork + clone the registry repo
    let tmpdir = tempfile::tempdir().map_err(|e| Error::Io {
        context: "failed to create temp directory".to_string(),
        source: e,
    })?;
    let clone_dir = tmpdir.path().join("registry");

    gh(&[
        "repo",
        "fork",
        repo,
        "--clone",
        "--remote=true",
        &format!("--={}", clone_dir.display()),
    ])
    .or_else(|_| {
        // Fork may already exist; try cloning directly
        gh(&["repo", "clone", repo, &clone_dir.display().to_string()])
    })
    .map_err(|_| Error::Publish(format!("failed to fork/clone registry repo {repo}")))?;

    // Create a publish branch
    let branch = format!("publish/{owner}/{name}/{version}");
    git_in(&clone_dir, &["checkout", "-b", &branch])?;

    // Copy the packed skillpack into the registry checkout
    let dest = clone_dir.join(&dest_rel);
    std::fs::create_dir_all(&dest).map_err(|e| Error::CreateDir {
        path: dest.clone(),
        source: e,
    })?;

    copy_skillpack(dir, &dest)?;

    // Stage, commit, push
    git_in(&clone_dir, &["add", &dest_rel])?;

    let commit_msg = format!("feat: publish {owner}/{name} v{version}");
    git_in(
        &clone_dir,
        &["-c", "commit.gpgsign=false", "commit", "-m", &commit_msg],
    )?;

    git_in(&clone_dir, &["push", "-u", "origin", &branch])?;

    // Create the PR
    let pr_title = format!("Publish {owner}/{name} v{version}");
    let pr_body = format!(
        "## Publish {owner}/{name}\n\n\
         - **Version**: {version}\n\
         - **Description**: {}\n\n\
         Auto-generated by `skillet publish`.",
        pack_result.validation.description
    );

    let output = gh_in(
        &clone_dir,
        &[
            "pr", "create", "--title", &pr_title, "--body", &pr_body, "--repo", repo,
        ],
    )?;

    let pr_url = output.trim().to_string();

    Ok(PublishResult {
        pack: pack_result,
        pr_url,
    })
}

/// Copy skill files from source to destination directory.
fn copy_skillpack(src: &Path, dst: &Path) -> crate::error::Result<()> {
    let required = ["skill.toml", "SKILL.md", "MANIFEST.sha256"];
    for name in &required {
        let from = src.join(name);
        let to = dst.join(name);
        std::fs::copy(&from, &to).map_err(|e| Error::Io {
            context: format!("failed to copy {}", from.display()),
            source: e,
        })?;
    }

    // versions.toml
    let versions_src = src.join("versions.toml");
    if versions_src.is_file() {
        std::fs::copy(&versions_src, dst.join("versions.toml")).map_err(|e| Error::Io {
            context: "failed to copy versions.toml".to_string(),
            source: e,
        })?;
    }

    // Extra directories (scripts/, references/, assets/, rules/, templates/)
    for subdir in EXTRA_DIRS {
        let sub_src = src.join(subdir);
        if sub_src.is_dir() {
            copy_dir_recursive(&sub_src, &dst.join(subdir))?;
        }
    }

    // README.md (optional)
    let readme_src = src.join("README.md");
    if readme_src.is_file() {
        std::fs::copy(&readme_src, dst.join("README.md")).map_err(|e| Error::Io {
            context: "failed to copy README.md".to_string(),
            source: e,
        })?;
    }

    Ok(())
}

/// Recursively copy a directory.
fn copy_dir_recursive(src: &Path, dst: &Path) -> crate::error::Result<()> {
    std::fs::create_dir_all(dst).map_err(|e| Error::CreateDir {
        path: dst.to_path_buf(),
        source: e,
    })?;

    for entry in std::fs::read_dir(src).map_err(|e| Error::FileRead {
        path: src.to_path_buf(),
        source: e,
    })? {
        let entry = entry?;
        let src_path = entry.path();
        let dst_path = dst.join(entry.file_name());
        if src_path.is_dir() {
            copy_dir_recursive(&src_path, &dst_path)?;
        } else {
            std::fs::copy(&src_path, &dst_path).map_err(|e| Error::Io {
                context: format!("failed to copy {}", src_path.display()),
                source: e,
            })?;
        }
    }

    Ok(())
}

/// Check that `gh` CLI is available and authenticated.
fn check_gh_cli() -> crate::error::Result<()> {
    let status = Command::new("gh")
        .args(["auth", "status"])
        .stdout(std::process::Stdio::null())
        .stderr(std::process::Stdio::null())
        .status();

    match status {
        Ok(s) if s.success() => Ok(()),
        Ok(_) => Err(Error::Publish(
            "gh CLI is not authenticated. Run `gh auth login` first.".to_string(),
        )),
        Err(_) => Err(Error::Publish(
            "gh CLI not found. Install it from https://cli.github.com/".to_string(),
        )),
    }
}

/// Run a `gh` command and return stdout.
fn gh(args: &[&str]) -> crate::error::Result<String> {
    let output = Command::new("gh")
        .args(args)
        .output()
        .map_err(|e| Error::Io {
            context: "failed to run gh".to_string(),
            source: e,
        })?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();
        return Err(Error::Publish(format!(
            "gh {} failed: {}",
            args.first().unwrap_or(&""),
            stderr
        )));
    }

    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}

/// Run a `gh` command in a specific directory.
fn gh_in(dir: &Path, args: &[&str]) -> crate::error::Result<String> {
    let output = Command::new("gh")
        .args(args)
        .current_dir(dir)
        .output()
        .map_err(|e| Error::Io {
            context: "failed to run gh".to_string(),
            source: e,
        })?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();
        return Err(Error::Publish(format!(
            "gh {} failed: {}",
            args.first().unwrap_or(&""),
            stderr
        )));
    }

    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}

/// Run a `git` command in a specific directory.
fn git_in(dir: &Path, args: &[&str]) -> crate::error::Result<String> {
    let output = Command::new("git")
        .args(args)
        .current_dir(dir)
        .output()
        .map_err(|e| Error::Io {
            context: "failed to run git".to_string(),
            source: e,
        })?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();
        return Err(Error::Git {
            operation: args.first().unwrap_or(&"").to_string(),
            stderr,
        });
    }

    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    /// Set up a source dir that mimics a packed skillpack.
    fn make_skillpack(dir: &Path) {
        std::fs::write(dir.join("skill.toml"), "[skill]\nname = \"test\"").unwrap();
        std::fs::write(dir.join("SKILL.md"), "# Test Skill").unwrap();
        std::fs::write(dir.join("MANIFEST.sha256"), "abc123  SKILL.md").unwrap();
    }

    #[test]
    fn copy_skillpack_copies_required_files() {
        let src = TempDir::new().unwrap();
        let dst = TempDir::new().unwrap();
        make_skillpack(src.path());

        copy_skillpack(src.path(), dst.path()).unwrap();

        assert!(dst.path().join("skill.toml").exists());
        assert!(dst.path().join("SKILL.md").exists());
        assert!(dst.path().join("MANIFEST.sha256").exists());
    }

    #[test]
    fn copy_skillpack_copies_versions_toml() {
        let src = TempDir::new().unwrap();
        let dst = TempDir::new().unwrap();
        make_skillpack(src.path());
        std::fs::write(src.path().join("versions.toml"), "[[versions]]").unwrap();

        copy_skillpack(src.path(), dst.path()).unwrap();

        assert!(dst.path().join("versions.toml").exists());
    }

    #[test]
    fn copy_skillpack_copies_readme() {
        let src = TempDir::new().unwrap();
        let dst = TempDir::new().unwrap();
        make_skillpack(src.path());
        std::fs::write(src.path().join("README.md"), "# Readme").unwrap();

        copy_skillpack(src.path(), dst.path()).unwrap();

        assert!(dst.path().join("README.md").exists());
    }

    #[test]
    fn copy_skillpack_copies_scripts_dir() {
        let src = TempDir::new().unwrap();
        let dst = TempDir::new().unwrap();
        make_skillpack(src.path());
        std::fs::create_dir(src.path().join("scripts")).unwrap();
        std::fs::write(src.path().join("scripts/lint.sh"), "#!/bin/bash").unwrap();

        copy_skillpack(src.path(), dst.path()).unwrap();

        assert!(dst.path().join("scripts/lint.sh").exists());
    }

    #[test]
    fn copy_skillpack_copies_rules_dir() {
        let src = TempDir::new().unwrap();
        let dst = TempDir::new().unwrap();
        make_skillpack(src.path());
        std::fs::create_dir(src.path().join("rules")).unwrap();
        std::fs::write(src.path().join("rules/cache-patterns.md"), "# Patterns").unwrap();

        copy_skillpack(src.path(), dst.path()).unwrap();

        assert!(dst.path().join("rules/cache-patterns.md").exists());
    }

    #[test]
    fn copy_skillpack_copies_templates_dir() {
        let src = TempDir::new().unwrap();
        let dst = TempDir::new().unwrap();
        make_skillpack(src.path());
        std::fs::create_dir(src.path().join("templates")).unwrap();
        std::fs::write(src.path().join("templates/config.toml"), "key = \"val\"").unwrap();

        copy_skillpack(src.path(), dst.path()).unwrap();

        assert!(dst.path().join("templates/config.toml").exists());
    }

    #[test]
    fn copy_skillpack_fails_missing_required() {
        let src = TempDir::new().unwrap();
        let dst = TempDir::new().unwrap();
        let result = copy_skillpack(src.path(), dst.path());
        assert!(result.is_err());
    }

    #[test]
    fn copy_skillpack_skips_absent_optional_dirs() {
        let src = TempDir::new().unwrap();
        let dst = TempDir::new().unwrap();
        make_skillpack(src.path());

        copy_skillpack(src.path(), dst.path()).unwrap();

        assert!(!dst.path().join("scripts").exists());
        assert!(!dst.path().join("rules").exists());
        assert!(!dst.path().join("templates").exists());
        assert!(!dst.path().join("README.md").exists());
        assert!(!dst.path().join("versions.toml").exists());
    }

    #[test]
    fn copy_dir_recursive_copies_nested() {
        let src = TempDir::new().unwrap();
        let dst = TempDir::new().unwrap();
        let sub = src.path().join("a").join("b");
        std::fs::create_dir_all(&sub).unwrap();
        std::fs::write(sub.join("file.txt"), "nested content").unwrap();
        std::fs::write(src.path().join("a").join("top.txt"), "top content").unwrap();

        let dest = dst.path().join("out");
        copy_dir_recursive(src.path().join("a").as_path(), &dest).unwrap();

        assert_eq!(
            std::fs::read_to_string(dest.join("top.txt")).unwrap(),
            "top content"
        );
        assert_eq!(
            std::fs::read_to_string(dest.join("b/file.txt")).unwrap(),
            "nested content"
        );
    }

    #[test]
    fn publish_dry_run_fails_before_gh() {
        // Dry run still requires pack() to succeed. We verify the error
        // comes from pack (validation), not from the gh CLI check.
        let dir = TempDir::new().unwrap();
        let result = publish(dir.path(), "owner/repo", None, true);
        assert!(result.is_err());
        let err = result.unwrap_err().to_string();
        assert!(!err.contains("gh CLI"), "dry_run should not reach gh check");
    }
}
