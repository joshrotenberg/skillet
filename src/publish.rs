//! Publish a skillpack to a registry by opening a PR via `gh`.

use std::path::Path;
use std::process::Command;

use crate::error::Error;
use crate::pack::{self, PackResult};

/// Result of publishing a skillpack.
#[derive(Debug)]
pub struct PublishResult {
    pub pack: PackResult,
    pub pr_url: String,
}

/// Pack the skill and open a PR against the registry repo.
///
/// `repo` is in `owner/repo` format (e.g. "joshrotenberg/skillet-registry").
/// If `dry_run` is true, stops after packing and prints what would happen.
pub fn publish(dir: &Path, repo: &str, dry_run: bool) -> crate::error::Result<PublishResult> {
    let pack_result = pack::pack(dir)?;

    let owner = &pack_result.validation.owner;
    let name = &pack_result.validation.name;
    let version = &pack_result.validation.version;

    if dry_run {
        println!("\nDry run: would publish {owner}/{name} v{version} to {repo}");
        println!("  - Fork {repo} (or use existing fork)");
        println!("  - Create branch: publish/{owner}/{name}/{version}");
        println!("  - Copy skillpack into {owner}/{name}/");
        println!("  - Open PR against {repo}");
        return Ok(PublishResult {
            pack: pack_result,
            pr_url: "(dry run)".to_string(),
        });
    }

    // Check that gh is available
    check_gh_cli()?;

    // Fork + clone the registry repo
    let tmpdir = tempfile::tempdir().map_err(|e| Error::Io {
        context: "failed to create temp directory".to_string(),
        source: e,
    })?;
    let clone_dir = tmpdir.path().join("registry");

    gh(&[
        "repo",
        "fork",
        repo,
        "--clone",
        "--remote=true",
        &format!("--={}", clone_dir.display()),
    ])
    .or_else(|_| {
        // Fork may already exist; try cloning directly
        gh(&["repo", "clone", repo, &clone_dir.display().to_string()])
    })
    .map_err(|_| Error::Publish(format!("failed to fork/clone registry repo {repo}")))?;

    // Create a publish branch
    let branch = format!("publish/{owner}/{name}/{version}");
    git_in(&clone_dir, &["checkout", "-b", &branch])?;

    // Copy the packed skillpack into the registry checkout
    let dest = clone_dir.join(owner).join(name);
    std::fs::create_dir_all(&dest).map_err(|e| Error::CreateDir {
        path: dest.clone(),
        source: e,
    })?;

    copy_skillpack(dir, &dest)?;

    // Stage, commit, push
    git_in(&clone_dir, &["add", &format!("{owner}/{name}")])?;

    let commit_msg = format!("feat: publish {owner}/{name} v{version}");
    git_in(
        &clone_dir,
        &["-c", "commit.gpgsign=false", "commit", "-m", &commit_msg],
    )?;

    git_in(&clone_dir, &["push", "-u", "origin", &branch])?;

    // Create the PR
    let pr_title = format!("Publish {owner}/{name} v{version}");
    let pr_body = format!(
        "## Publish {owner}/{name}\n\n\
         - **Version**: {version}\n\
         - **Description**: {}\n\n\
         Auto-generated by `skillet publish`.",
        pack_result.validation.description
    );

    let output = gh_in(
        &clone_dir,
        &[
            "pr", "create", "--title", &pr_title, "--body", &pr_body, "--repo", repo,
        ],
    )?;

    let pr_url = output.trim().to_string();

    Ok(PublishResult {
        pack: pack_result,
        pr_url,
    })
}

/// Copy skill files from source to destination directory.
fn copy_skillpack(src: &Path, dst: &Path) -> crate::error::Result<()> {
    let required = ["skill.toml", "SKILL.md", "MANIFEST.sha256"];
    for name in &required {
        let from = src.join(name);
        let to = dst.join(name);
        std::fs::copy(&from, &to).map_err(|e| Error::Io {
            context: format!("failed to copy {}", from.display()),
            source: e,
        })?;
    }

    // versions.toml
    let versions_src = src.join("versions.toml");
    if versions_src.is_file() {
        std::fs::copy(&versions_src, dst.join("versions.toml")).map_err(|e| Error::Io {
            context: "failed to copy versions.toml".to_string(),
            source: e,
        })?;
    }

    // Extra directories: scripts/, references/, assets/
    for subdir in &["scripts", "references", "assets"] {
        let sub_src = src.join(subdir);
        if sub_src.is_dir() {
            copy_dir_recursive(&sub_src, &dst.join(subdir))?;
        }
    }

    // README.md (optional)
    let readme_src = src.join("README.md");
    if readme_src.is_file() {
        std::fs::copy(&readme_src, dst.join("README.md")).map_err(|e| Error::Io {
            context: "failed to copy README.md".to_string(),
            source: e,
        })?;
    }

    Ok(())
}

/// Recursively copy a directory.
fn copy_dir_recursive(src: &Path, dst: &Path) -> crate::error::Result<()> {
    std::fs::create_dir_all(dst).map_err(|e| Error::CreateDir {
        path: dst.to_path_buf(),
        source: e,
    })?;

    for entry in std::fs::read_dir(src).map_err(|e| Error::FileRead {
        path: src.to_path_buf(),
        source: e,
    })? {
        let entry = entry?;
        let src_path = entry.path();
        let dst_path = dst.join(entry.file_name());
        if src_path.is_dir() {
            copy_dir_recursive(&src_path, &dst_path)?;
        } else {
            std::fs::copy(&src_path, &dst_path).map_err(|e| Error::Io {
                context: format!("failed to copy {}", src_path.display()),
                source: e,
            })?;
        }
    }

    Ok(())
}

/// Check that `gh` CLI is available and authenticated.
fn check_gh_cli() -> crate::error::Result<()> {
    let status = Command::new("gh")
        .args(["auth", "status"])
        .stdout(std::process::Stdio::null())
        .stderr(std::process::Stdio::null())
        .status();

    match status {
        Ok(s) if s.success() => Ok(()),
        Ok(_) => Err(Error::Publish(
            "gh CLI is not authenticated. Run `gh auth login` first.".to_string(),
        )),
        Err(_) => Err(Error::Publish(
            "gh CLI not found. Install it from https://cli.github.com/".to_string(),
        )),
    }
}

/// Run a `gh` command and return stdout.
fn gh(args: &[&str]) -> crate::error::Result<String> {
    let output = Command::new("gh")
        .args(args)
        .output()
        .map_err(|e| Error::Io {
            context: "failed to run gh".to_string(),
            source: e,
        })?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();
        return Err(Error::Publish(format!(
            "gh {} failed: {}",
            args.first().unwrap_or(&""),
            stderr
        )));
    }

    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}

/// Run a `gh` command in a specific directory.
fn gh_in(dir: &Path, args: &[&str]) -> crate::error::Result<String> {
    let output = Command::new("gh")
        .args(args)
        .current_dir(dir)
        .output()
        .map_err(|e| Error::Io {
            context: "failed to run gh".to_string(),
            source: e,
        })?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();
        return Err(Error::Publish(format!(
            "gh {} failed: {}",
            args.first().unwrap_or(&""),
            stderr
        )));
    }

    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}

/// Run a `git` command in a specific directory.
fn git_in(dir: &Path, args: &[&str]) -> crate::error::Result<String> {
    let output = Command::new("git")
        .args(args)
        .current_dir(dir)
        .output()
        .map_err(|e| Error::Io {
            context: "failed to run git".to_string(),
            source: e,
        })?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();
        return Err(Error::Git {
            operation: args.first().unwrap_or(&"").to_string(),
            stderr,
        });
    }

    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}
