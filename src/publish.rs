//! Publish a skillpack to a registry by opening a PR via `gh`.

use std::path::Path;
use std::process::Command;

use anyhow::{Context, bail};

use crate::pack::{self, PackResult};

/// Result of publishing a skillpack.
#[derive(Debug)]
pub struct PublishResult {
    pub pack: PackResult,
    pub pr_url: String,
}

/// Pack the skill and open a PR against the registry repo.
///
/// `repo` is in `owner/repo` format (e.g. "joshrotenberg/skillet-registry").
/// If `dry_run` is true, stops after packing and prints what would happen.
pub fn publish(dir: &Path, repo: &str, dry_run: bool) -> anyhow::Result<PublishResult> {
    let pack_result = pack::pack(dir)?;

    let owner = &pack_result.validation.owner;
    let name = &pack_result.validation.name;
    let version = &pack_result.validation.version;

    if dry_run {
        println!("\nDry run: would publish {owner}/{name} v{version} to {repo}");
        println!("  - Fork {repo} (or use existing fork)");
        println!("  - Create branch: publish/{owner}/{name}/{version}");
        println!("  - Copy skillpack into {owner}/{name}/");
        println!("  - Open PR against {repo}");
        return Ok(PublishResult {
            pack: pack_result,
            pr_url: "(dry run)".to_string(),
        });
    }

    // Check that gh is available
    check_gh_cli()?;

    // Fork + clone the registry repo
    let tmpdir = tempfile::tempdir().context("Failed to create temp directory")?;
    let clone_dir = tmpdir.path().join("registry");

    gh(&[
        "repo",
        "fork",
        repo,
        "--clone",
        "--remote=true",
        &format!("--={}", clone_dir.display()),
    ])
    .or_else(|_| {
        // Fork may already exist; try cloning directly
        gh(&["repo", "clone", repo, &clone_dir.display().to_string()])
    })
    .context("Failed to fork/clone registry repo")?;

    // Create a publish branch
    let branch = format!("publish/{owner}/{name}/{version}");
    git_in(&clone_dir, &["checkout", "-b", &branch])?;

    // Copy the packed skillpack into the registry checkout
    let dest = clone_dir.join(owner).join(name);
    std::fs::create_dir_all(&dest)
        .with_context(|| format!("Failed to create {}", dest.display()))?;

    copy_skillpack(dir, &dest)?;

    // Stage, commit, push
    git_in(&clone_dir, &["add", &format!("{owner}/{name}")])?;

    let commit_msg = format!("feat: publish {owner}/{name} v{version}");
    git_in(&clone_dir, &["commit", "-m", &commit_msg])?;

    git_in(&clone_dir, &["push", "-u", "origin", &branch])?;

    // Create the PR
    let pr_title = format!("Publish {owner}/{name} v{version}");
    let pr_body = format!(
        "## Publish {owner}/{name}\n\n\
         - **Version**: {version}\n\
         - **Description**: {}\n\n\
         Auto-generated by `skillet publish`.",
        pack_result.validation.description
    );

    let output = gh_in(
        &clone_dir,
        &[
            "pr", "create", "--title", &pr_title, "--body", &pr_body, "--repo", repo,
        ],
    )?;

    let pr_url = output.trim().to_string();

    Ok(PublishResult {
        pack: pack_result,
        pr_url,
    })
}

/// Copy skill files from source to destination directory.
fn copy_skillpack(src: &Path, dst: &Path) -> anyhow::Result<()> {
    let required = ["skill.toml", "SKILL.md", "MANIFEST.sha256"];
    for name in &required {
        let from = src.join(name);
        let to = dst.join(name);
        std::fs::copy(&from, &to).with_context(|| format!("Failed to copy {}", from.display()))?;
    }

    // versions.toml
    let versions_src = src.join("versions.toml");
    if versions_src.is_file() {
        std::fs::copy(&versions_src, dst.join("versions.toml"))
            .context("Failed to copy versions.toml")?;
    }

    // Extra directories: scripts/, references/, assets/
    for subdir in &["scripts", "references", "assets"] {
        let sub_src = src.join(subdir);
        if sub_src.is_dir() {
            copy_dir_recursive(&sub_src, &dst.join(subdir))?;
        }
    }

    // README.md (optional)
    let readme_src = src.join("README.md");
    if readme_src.is_file() {
        std::fs::copy(&readme_src, dst.join("README.md")).context("Failed to copy README.md")?;
    }

    Ok(())
}

/// Recursively copy a directory.
fn copy_dir_recursive(src: &Path, dst: &Path) -> anyhow::Result<()> {
    std::fs::create_dir_all(dst).with_context(|| format!("Failed to create {}", dst.display()))?;

    for entry in
        std::fs::read_dir(src).with_context(|| format!("Failed to read {}", src.display()))?
    {
        let entry = entry?;
        let src_path = entry.path();
        let dst_path = dst.join(entry.file_name());
        if src_path.is_dir() {
            copy_dir_recursive(&src_path, &dst_path)?;
        } else {
            std::fs::copy(&src_path, &dst_path)
                .with_context(|| format!("Failed to copy {}", src_path.display()))?;
        }
    }

    Ok(())
}

/// Check that `gh` CLI is available and authenticated.
fn check_gh_cli() -> anyhow::Result<()> {
    let status = Command::new("gh")
        .args(["auth", "status"])
        .stdout(std::process::Stdio::null())
        .stderr(std::process::Stdio::null())
        .status();

    match status {
        Ok(s) if s.success() => Ok(()),
        Ok(_) => bail!("gh CLI is not authenticated. Run `gh auth login` first."),
        Err(_) => bail!("gh CLI not found. Install it from https://cli.github.com/"),
    }
}

/// Run a `gh` command and return stdout.
fn gh(args: &[&str]) -> anyhow::Result<String> {
    let output = Command::new("gh")
        .args(args)
        .output()
        .context("Failed to run gh")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        bail!("gh {} failed: {}", args.first().unwrap_or(&""), stderr);
    }

    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}

/// Run a `gh` command in a specific directory.
fn gh_in(dir: &Path, args: &[&str]) -> anyhow::Result<String> {
    let output = Command::new("gh")
        .args(args)
        .current_dir(dir)
        .output()
        .context("Failed to run gh")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        bail!("gh {} failed: {}", args.first().unwrap_or(&""), stderr);
    }

    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}

/// Run a `git` command in a specific directory.
fn git_in(dir: &Path, args: &[&str]) -> anyhow::Result<String> {
    let output = Command::new("git")
        .args(args)
        .current_dir(dir)
        .output()
        .context("Failed to run git")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        bail!("git {} failed: {}", args.first().unwrap_or(&""), stderr);
    }

    Ok(String::from_utf8_lossy(&output.stdout).to_string())
}
